<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>L-System Animation Loader</title>
  <link rel="stylesheet" href="style.css">
  <style>
    
    #controls {
      position: fixed;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      z-index: 10;
    }
    
    #restartBtn {
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="controls">
    <label style="color:white;font-size:13px;">Speed <input type="range" id="speedSlider" min="1" max="150" value="20"></label>
    <button id="editBtn">Edit</button>
    
    <button id="restartBtn">Restart</button>
  </div>
  <div id="notice"></div>

  <script>
    function showNotice(msg, timeout=3000){
      const n=document.getElementById('notice');
      n.textContent=msg;
      n.style.display='block';
      clearTimeout(n._t);
      n._t=setTimeout(()=>n.style.display='none',timeout);
    }

    // ---- L-System Generator ----
    function genLSystem(params){
      let { axiom, rules, symbols, length, iterations } = params;
      let str=axiom;
      const ruleMap={};
      rules.forEach(r=>ruleMap[r.a]=r.b);

      for(let i=0;i<iterations;i++){
        let next='';
        for(const ch of str) next += ruleMap[ch]||ch;
        str=next;
        if(str.length>200000) break;
      }

      let x=0,y=0,dir=-Math.PI/2;
      const stack=[];
      const pts=[];
      let currentColor='#000';

      for(const ch of str){
        const action=symbols[ch];
        if(!action) continue;
        if(action.type==='draw'){
          const len=parseFloat(action.length)||length||10;
          currentColor=action.color||currentColor;
          const nx=x+Math.cos(dir)*len;
          const ny=y+Math.sin(dir)*len;
          pts.push({x,y,nx,ny,color:currentColor});
          x=nx;y=ny;
        } else if(action.type==='turn'){
          dir += (parseFloat(action.angle)||0)*Math.PI/180;
        } else if(action.type==='push'){
          stack.push({x,y,dir,currentColor});
        } else if(action.type==='pop'){
          const s=stack.pop();
          if(s){x=s.x;y=s.y;dir=s.dir;currentColor=s.currentColor;}
        }
      }
      return {points:pts,meta:{text:str}};
    }

    // ---- Animation ----
    const canvas=document.getElementById('canvas');
    const ctx=canvas.getContext('2d');
    let shapeData=null;
    let animIndex=0;
    let speed=2;
    let state={zoom:1,offsetX:0,offsetY:0};
    let isPanning=false; let last={x:0,y:0}; let lastDist=null;

    function renderAnim(){
      canvas.width=canvas.clientWidth*devicePixelRatio;
      canvas.height=canvas.clientHeight*devicePixelRatio;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      ctx.translate(canvas.width/2+state.offsetX,canvas.height/2+state.offsetY);
      ctx.scale(state.zoom,state.zoom);

      if(shapeData && shapeData.points){
        for(let i=0;i<animIndex && i<shapeData.points.length;i++){
          const seg=shapeData.points[i];
          ctx.beginPath();
          ctx.moveTo(seg.x,seg.y);
          ctx.lineTo(seg.nx,seg.ny);
          ctx.strokeStyle=seg.color;
          ctx.lineWidth=1/state.zoom;
          ctx.stroke();
        }
        if(animIndex<shapeData.points.length){
          animIndex+=speed;
          requestAnimationFrame(renderAnim);
        } else {
          document.getElementById('restartBtn').style.display='block';
        }
      }
      ctx.restore();
    }

    // ---- Controls ----
    document.getElementById('speedSlider').oninput=e=>{speed=parseInt(e.target.value)||2;};
    document.getElementById('restartBtn').onclick=()=>{
      animIndex=0;
      document.getElementById('restartBtn').style.display='none';
      requestAnimationFrame(renderAnim);
    };

    // ---- Navigation (mouse + touch) ----
    canvas.addEventListener('mousedown',e=>{isPanning=true;last={x:e.clientX,y:e.clientY};});
    canvas.addEventListener('mousemove',e=>{if(isPanning){state.offsetX+=(e.clientX-last.x);state.offsetY+=(e.clientY-last.y);last={x:e.clientX,y:e.clientY};}});
    canvas.addEventListener('mouseup',()=>isPanning=false);
    canvas.addEventListener('mouseleave',()=>isPanning=false);
    canvas.addEventListener('wheel',e=>{e.preventDefault();state.zoom*=e.deltaY<0?1.1:0.9;},{passive:false});

    canvas.addEventListener('touchstart',e=>{
      if(e.touches.length===2){lastDist=getDist(e.touches);} 
      else if(e.touches.length===1){isPanning=true;last={x:e.touches[0].clientX,y:e.touches[0].clientY};}
      e.preventDefault();
    },{passive:false});

    canvas.addEventListener('touchmove',e=>{
      if(e.touches.length===2 && lastDist){
        const newD=getDist(e.touches);
        state.zoom*=newD/lastDist;
        lastDist=newD;
      } else if(e.touches.length===1 && isPanning){
        state.offsetX+=(e.touches[0].clientX-last.x);
        state.offsetY+=(e.touches[0].clientY-last.y);
        last={x:e.touches[0].clientX,y:e.touches[0].clientY};
      }
      e.preventDefault();
    },{passive:false});

    canvas.addEventListener('touchend',e=>{if(e.touches.length<2)lastDist=null;if(e.touches.length===0)isPanning=false;},{passive:false});

    function getDist(touches){
      const dx=touches[0].clientX-touches[1].clientX;
      const dy=touches[0].clientY-touches[1].clientY;
      return Math.hypot(dx,dy);
    }

    // ---- Load from URL ----
    function loadParamsFromURL(){
      const urlParams=new URLSearchParams(location.search);
      const encoded=urlParams.get("data");
      if(encoded){
        try{
          const json=decodeURIComponent(escape(atob(encoded)));
          const params=JSON.parse(json);
          shapeData=genLSystem(params);
          animIndex=0;
          state={zoom:1,offsetX:0,offsetY:0};
          document.getElementById('restartBtn').style.display='none';
          showNotice("Loaded configuration from URL. Starting animation...");
          requestAnimationFrame(renderAnim);
        }catch(e){
          console.error(e);
          showNotice("Invalid shared link.");
        }
      } else {
        showNotice("No ?data= found in URL");
      }
    }

    loadParamsFromURL();
    document.getElementById("editBtn").onclick = () => {
  const urlParams = new URLSearchParams(location.search);
  const encoded = urlParams.get("data");
  if (encoded) {
    const editUrl = `${location.origin}${location.pathname.replace("animation.html","")}index.html?data=${encoded}`;
    location.href = editUrl; // באותו חלון
  } else {
    alert("No data found to edit!");
  }
};
    
  </script>
</body>
</html>
